# June 13th, 2025

Today I implemented more MBC behavior, but I decided to come back to MBC3 at a later time because handling the RTC is just more difficult than I can currently understand. I think I will implement that closer to the end, but for now I can still run a bunch of test ROMs. 

I also began implementing the system clock and how it affects the hardware. I think the solution I came up with is pretty nice, which ends up being 1 function to call that updates the hardware based on the number of cycles that have passed. That way, I can call it whenever I need to (even mid-instruction if I want cycle-perfect emulation at some point), and it also updates everything in 1 function call, which is pretty accurate to how the hardware actually works since it all works in parallel. I started working on updating the DIV register, which is at 0xFF04, and it was kind of confusing at first, but after learning about it, it makes a lot of sense. At first it's weird rules like "every 256 M-cycles this increments", and then there's the TIMA and TAC registers, and TIMA increments based on TAC's value, and it was looking to be another case of just keeping track of more things than I think that I should have to, but it actually makes a lot of intuitive sense once you break it down. For instance, DIV is just the upper 8 bits of the system clock, which explains why it only increments every so many cycles. And TIMA increments based on detecting a falling edge at a specified bit in the system clock. So it ends up kinda working out in a nice way when you realize all the weird rules and math are actually are SUPER intuitive. You just have to increment the system timer, which updates DIV, and then check for the bit TAC specifies to see if TIMA should be incremented. There are still some dumb rules though, but those shouldn't be as bad now that I have an intuitive understanding for how the timing works at the hardware level.

Speaking of which, I was kind of confused because I read both that the system timer is 16 bits and also 14 bits, but apparently that is because the timer is 16 bits, but the highest 2 bits are used for timing when the system gets booted (which is not relevant for emulation), and the lower 14 bits get incremented per M-cycle. Which is really funny because since 4 T-cycles is 1 M-cycle, if you treat the system clock as a 16-bit variable and increment it each T-cycle, then the clock ends up being the exact same since the timing is all based off of M-cycles. So as long as the rest of the system does timing in T-cycles, the math should work out the same, which means that my decision to base all the instructions off of T-cycles was the correct one (thankfully).

So ya, the goal now is to finish getting the CPU timing under control, and then I think I'll handle interrupts (which don't seem terribly difficult, but historically that means it'll probably take me forever to do). Then hopefully I can finally get basic PPU support and be able to officially run a ROM! I'm sure there will be a lot more tedious stuff in between, but that's the roadmap at the moment.
