# Overall 
(These logs will be ramble-y)
(Note that not all of the information in here will be 100% correct-- It is just to the best of my knowledge. Some terminology or details may not be fully accurate.)

## General
This project has been a lot of fun so far, and it's making me think in a way about this stuff I haven't really before. I guess its true when they say that the best way to learn about a computer is to emulate it or something like that. I've noticed that through this project so far, I have used almost no loops at all, which really makes sense when you think about it! Cuz really a computer just executes instructions one after the other, the concept of loops as we know them is just a result of those instructions, so that's been an interesting observation to make. Because of that, I've thought a lot about different ways to make programming everything less tedious because (spoiler alert) the GameBoy has 500 different instructions, and accounting for all of them is super annoying. So in this project I've used macros more than I ever have before as well as enums, and I've really spent a LOT more time trying to write my code in a modular way because there's so many little edge cases and ways to mess up, so I've been trying to make that better. Anyway part isn't really a design note as much as a reflection but that's okay.

## CPU
The GameBoy CPU generally acts like you'd expect any CPU to act, at least of the ones that I've learned about... It has 8 8-bit registers, and then 2 special 16-bit registers (PC and SP), but SOMETIMES you can combine certain 8-bit registers to be 16-bit. The A register is the accumulator register and the F register is the flag register. My implementation of this part initially felt kinda messy because there are a few switch statements, but this helped a lot with abstracting a lot of the instruction set logic. Being able to pass in an enum and have the CPU function just figure out what to do about it cut down on a lot of work (I could have cut down a lot more too but I'll get to that). It's also just a cruel reminder of how silly C can be sometimes, but the flexibility has actually been something that I've enjoyed a lot so far.

## Instruction Set
I mentioned above that the GameBoy instruction set has 500 instructions, and implementing this was a REAL pain. Every resource out there about these is like "Hey, here's how you implement the add instruction and the load instruction, so now you can go do the rest!" and so I wasn't prepared for it to be SO annoying. I ended up making a big lookup table for each opcode, what the instruction was, and what the parameters were. This did take absolutely forever, but it is nice because now when I end up decoding the instruction loop, its just an O(1) lookup to get all the necessary information, which is super nice! But in hindsight, I think it might have been a better idea to actually decode the opcode at a slight cost of performance. Implementing the instructions themselves isn't actually 500 functions, but I think I had over 100 total, which is still probably a lot more than necessary. This is because there's different combinations of the same instruction. There's "ld A, B", "ld A, C" and so on. So that's where having all those switch statements in my CPU helped out, because I could just pass those in from the instruction. But despite that, there's still some really weird ones and some edge cases, so I did end up having a bunch. I aimed to keep the implementations themselves mostly clean without any messy logic, because it's either "have a massive switch statement in a single load function" or "have 20 load functions for different operand types" and I ended up going with the latter, although in hindsight I probably could have done something in the middle, like if the register input was HL then that almost always meant that there was a load from the address stored there. I did end up doing something like that towards the end, and I think if I was more clever I could have done it elsewhere as well. Regardless, I think that overall the implementation of this was clean and performant, but maybe took a significantly longer time than I would have liked... Oh well!

## Memory
The GameBoy has a 16-bit address space, and it's kind of interesting because pretty much everything gets read directly from memory, and even hardware specific things are handled via interrupts, which is fun! I decided to just have a placeholder "mem_read" and "mem_write" function at first so I could do the instruction set first. I was initially going to have that then go off into different functions for different sections of memory since each section is implemented separately, but the solution I ended up coming up with I think is a lot nicer, which is to have a helper function that just returns a pointer to the correct location and a helper function to just return whether that area is readable/writable. That meant that I only had to do the big "if address is between these values, then do this" once instead of twice, and being able to check if the memory location is accessible at that moment also helped clear up any weird logic in the read/write functions. So ultimately the mem_read and mem_write functions ended up being pretty nice! One thing about how memory works in the GameBoy is that a lot of the times games have switchable memory banks, so memory doesn't always point to the same exact place depending on different factors, and so I've triiied to implement a system that will make that work out in the long run, but I suppose we'll see how the exact handling will work...

## Other
### DMA Transfer
The GameBoy has a lot of fun little quirks. Like I mentioned above that SOME memory addresses aren't accessible at certain times, and this is because the memory bus is sometimes being hogged by different things. Since the GameBoy has its own screen and PPU, it doesn't rely on an external display. This is somewhat more flexible because there aren't strict, set timings for everything, but it also leads to some silly behavior. During the rendering process, the PPU will read the data for the scanline it's on, and during that time the CPU can NOT access certain memory. I think it's because the PPU is using the memory bus, but I also think that at times the CPU is just locked out of doing a lot of things regardless. There's one process called DMA Transfer, which is basically a super fast transfer to OAM (Object Attribute Memory), and during this time, the CPU is locked out of everywhere in memory but HRAM, which is 0xFF00-0xFFFF. This is also because DMA is hogging the memory bus, aaand if I had to throw a wild guess out there, since a DMA transfer request only specifies the upper byte of the address, the CPU can only address the lower byte, which is why it can only access memory where the upper byte is 0xFF.
 
### GameBoy Color
So as a fun video game history lesson, Nintendo released the GameBoy Color as a whole new handheld console, but the hardware is actually VERY similar to the original GameBoy with some slight changes. I am focusing on implementing original DMG behavior properly first, but I will make it compatible with GameBoy Color hardware as well. I do just want to say that the DMA transfer stuff is a bit different on GameBoy Color since it has separate buses for WRAM and cartridge memory apparently, so you CAN technically access different parts of memory during a DMA scan, but also sometimes the PPU is accessing VRAM. It's a lot of weird conditions just one after the other...

### Abstractions
So I was INITIALLY not 100% certain how I was going to handle a lot of this because some instructions needed to access memory, some needed to access the CPU, and the CPU has to access memory sometimes, so I was really trying to avoid any circular dependencies, but it ended up making the most sense to have the CPU and PPU and APU have a pointer to memory, and then just make memory be the big independent module. And I think that makes the most sense intuitively but also when you consider the hardware. Like I said, pretty much EVERYTHING is written in memory somewhere, including I/O peripherals. So as long as everything can 1.) check the status of whatever registers it needs and 2.) update those registers as needed, then there should be no weird dependencies, and so far that has proven true. The instruction set for instance just includes the CPU, because the CPU is what executes the instructions. So everything should be nice and modular!

### Performance Considerations
I've been attempting to consider the performance of this emulator as I go, but I've generally prioritized readability and scalability, and I think that's just the correct call. For instance, since some hardware registers are uniquely read only, write only, or some mix of the two, I was super temped to try to come up with a clever way to figure out the rules for each one. The problem is that the vast majority of memory addresses in that range work exactly the same, and there's a handful with different rules. I considered things like having an array of pointers so I didn't need duplicates of any structs, or using a hash map so that I only had to implement the ones that were different, having each read/write function have a unique array so they can loop through it and check against the list, etc. But at the end of the day the struct was literally 3 bytes (read mask, write mask, and a boolean), and if I initialize it once at the start, then I have constant lookup times each time I read/write to one. Like any fancy solution just introduces unnecessary overhead, and the only real benefit is saving what... 700 bytes of memory? For references, at this moment this log file is nearly 10kb. All that said, the GameBoy Color CPU has a clock speed at MOST of ~8MHz, and regular DMG has half that, so it's not exactly too difficult for an emulator to keep up with that on a modern computer. Even low-end computers from 15 years ago are hundreds of times faster than that. Combine that with compilers being really good at optimizing little quirks like that, and its just not really a big deal for a project like this. Because of that, I've been tending to lean more towards the design rather than the optimization of it all. I can totally see if you're trying to emulate a much newer piece of hardware why you'd want to squeeze out as many extra clock cycles as possible, but the GameBoy can run on a TI-83 so I think I'm okay as long as I'm not being really dumb with stuff, which I don't think I am...

### Echo RAM
This is more of something that I just find interesting, which is that the address range from 0xE000-0xFDFF points to the same memory as 0xC000-DDFF. This apparently this is because the address bus that accesses WRAM only reads the lower 13 bits, and the address space that maps to WRAM is 0xC000-0xFDFF. But since the top 3 bits are not even read, 0001 and 0000 are the only 2 unique values for the uppermost nibble, so the range for the upper byte ends up going from 0000 0000 (0x00) to 0001 1111 (0x1F) starting at the address 0xC0, and then after that even though the memory address is different, the address bus takes it to the same place, effectively looping it back. Basically this is quite literally due to an overflow of the 12th bit, which is a really fun concept to see in action! It's one of those "wait why didn't they just like design it better" moments, which leads to one of those "hardware design is a unique challenge and decisions like this help reduce cost and improve performance" moments, so that's fun. Either way i just wanted to talk about that.

## Accuracy
Having a completely accurate emulator is hard for any computer, but the GameBoy especially has just some very strange rules. Like "if you write here during this time, then it'll write garbage data from here" and its like... Okay, I can see why that might happen physically, but emulating it is nearly impossible to control. The big thing is getting the timing of everything correct, which I am trying to address by keeping track of the number of ticks each instruction takes, which will hopefully allow the timing to be accurate enough that you wouldn't notice a difference if you were to play a game normally. I know that games like Pokemon Red/Blue have glitches that are crazy enough to rely on these weird timing differences and mid-instruction quirks, so I decided early on that my goal was not "cycle accurate emulation" but "emulation so that if you were to load a game ROM you wouldn't even notice unless you are looking". There are special test ROMs that are meant to test a bunch of different quirks and check for emulator accuracy, and I have not heard of a single emulator that passed every single test ROM for every single little weird quirk. The most accurate emulator appears to be SameBoy, which successfully passes MOST test ROMs, but even that fails a couple of edge cases. Regardless, my goal is to at least have accurate enough emulation that my emulator can be fully functional and pass a handful of the weird edge case tests.

